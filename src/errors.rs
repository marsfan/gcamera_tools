/*
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at https: //mozilla.org/MPL/2.0/.
*/
//! Enumeration of errors the tool can produce.

use std::{error::Error, fmt, io::ErrorKind};

use crate::jpeg::xmp::SemanticType;

/// Enumeration of errors generated by the tool.
#[derive(PartialEq, Eq, Debug)]
pub enum GCameraError {
    /// Indicates something went wrong with reading the image.
    ImageReadError { kind: ErrorKind },

    /// Indicates something went wrong saving the image.
    ImageWriteError { kind: ErrorKind },

    ///Indicates something went wrong saving the debug data
    DebugDataWriteError { kind: ErrorKind },

    /// Indicates something went wro ng with saving the motion video
    MotionVideoWriteError { kind: ErrorKind },

    /// Indicates that the provided file does not have the correct magic bytes
    /// to be a JPEG file.
    InvalidJpegMagic,

    /// Indicates that somehow the one of the `data` or `length` members
    /// of `JpegSegment` is `None`, while the other is `Some`. This should
    /// not be possible at all, so we need to error out right away.
    LengthDataNotSameOption,

    /// Indicates that parsing the XML Document failed
    XMLParsingError {
        /// The XML Parser error
        xml_error: roxmltree::Error,
    },

    /// Indicates that an XML attribute could not be parsed
    XMLAttributeParseError {
        /// The value of the attribute
        attribute: Option<String>,
    },

    /// Indicates that XMP Data could not be found in any segments.
    NoXMPData,

    /// Indicates that the Description Node could not be found in the XML
    DescriptionNodeNotFound,

    /// Indicates that the given semantic string is not a known type.
    UnknownResourceSemantic {
        /// The string that could not be converted to a semantic enum.
        semantic: String,
    },

    /// Indicates that the given MIME Type is not known by the tool
    UnknownMimeType {
        /// The string that could not be converted to the Mimetype Enum
        mime: String,
    },

    /// Indicates that the given magic start point could not be found.
    MagicNotFound {
        /// The magic that was being searched for.
        magic: String,
    },

    /// Indicates that the next JPEG marker could not be found.
    JpegMarkerNotFound,

    /// Indicates that the type of JPEG Marker is not known.
    UnknownJpegMarker {
        /// The bytes of the unknown marker.
        marker_byte: u8,
    },

    /// Indicates that the image contains no resources of the given type
    NoResourcesOfType {
        /// The type of resource that was searched for
        semantic_type: SemanticType,
    },
}

impl fmt::Display for GCameraError {
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        return match self {
            GCameraError::ImageReadError { kind } => {
                write!(formatter, "Error reading the image. Kind: {kind}")
            }
            GCameraError::ImageWriteError { kind } => {
                write!(formatter, "Error writing the image. Kind: {kind}")
            }
            GCameraError::DebugDataWriteError { kind } => {
                write!(formatter, "Error writing the debug data. Kind: {kind}")
            }
            GCameraError::MotionVideoWriteError { kind } => {
                write!(formatter, "Error writing the motion video. Kind: {kind}")
            }
            GCameraError::InvalidJpegMagic => {
                write!(formatter, "File does not start with valid JPEG Magic.!")
            }
            GCameraError::LengthDataNotSameOption => {
                write!(formatter, "Data and length must either both be None, or both be some. This should not be possible.")
            }
            GCameraError::XMLParsingError { xml_error } => {
                write!(
                    formatter,
                    "Error parsing XML Document. XML Error: {xml_error}."
                )
            }
            GCameraError::XMLAttributeParseError { attribute } => {
                write!(
                    formatter,
                    "Error parsing XML Attribute to a u32. Attribute: {attribute:?}.",
                )
            }
            GCameraError::NoXMPData => write!(formatter, "No XMP Data found in the image."),
            GCameraError::DescriptionNodeNotFound => {
                write!(formatter, "Description not found in XMP data.")
            }
            GCameraError::UnknownResourceSemantic { semantic } => {
                write!(
                    formatter,
                    "Resource has an unknown semantic type of '{semantic}'."
                )
            }
            GCameraError::UnknownMimeType { mime } => {
                write!(formatter, "Resource has an unknown MIME Type of '{mime}'")
            }
            GCameraError::MagicNotFound { magic } => {
                write!(formatter, "Could not find magic '{magic}' in image.")
            }
            GCameraError::JpegMarkerNotFound => {
                write!(formatter, "Could not find another JPEG Segment Marker.")
            }
            GCameraError::UnknownJpegMarker { marker_byte } => {
                write!(
                    formatter,
                    "JPEG Marker with bytes '{marker_byte:02x}' is not known.",
                )
            }
            GCameraError::NoResourcesOfType { semantic_type } => {
                write!(
                    formatter,
                    "The image contains no resources of type {semantic_type:?}"
                )
            }
        };
    }
}

impl Error for GCameraError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        return match self {
            GCameraError::XMLParsingError { xml_error } => Some(xml_error),
            _ => None,
        };
    }
}
